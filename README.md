#   브루트포스  
  -순열  (부등호, 단어수학, 연산자끼워넣기, 스타트와링크)  
  -재귀  (로또, 부분수열의합(1,2), 연산자끼워넣기(1,재귀), 테트로미노, 두동전, 에너지모으기, 백트래킹(nqueen,스도쿠,알파벳))  
  -비트마스크  (부분수열의합(비트), 가르침, 구슬탈출2, 2048(EASY))
  -백트래킹  (스도쿠, 알파벳, nqueen)
  
#  BFS 
  -4연산, DSLR, 데스나이트, 돌그룹, 레이저통신, 뱀과사다리게임, 벽부수고이동하기1, 벽부수고이동하기2, 벽부수고이동하기3, 벽부수고이동하기4, 소수경로, 아기상어, 연구소, 움직이는미로탈출, 적록색약  

#  그리디 알고리즘
  -30,가장 긴 증가부분수열2, 동전0, 동전뒤집기, 보석도둑(1,2), 수묶기, 순회강연, 잃어버린괄호, 전구와스위치, 행렬, 회의실배정, A와B, AB, ATM
 
#  분할 정복  
  -이분탐색  (숫자카드(1,2))  
  -mergesort  (배열합치기, mergesort)
  -quicksort  (quicksort)
  -버블소트, 별찍기(10,11), 사분면, 종이의개수, 트리의순회, 하노이탑이동순서, Z


#  문제
**부등호(2529) : 부등호 배열을 우선배치하고 그 배열에 맞는 가장 크고 작은 숫자배열을 찾는문제. next_permutation 사용(permutation 전에 sorting 필요), 가장 큰 숫자배열은 가장 큰 수들 987...의 배열임.

**단어수학(1339) : 문자열 들의 알파벳을 숫자로 바꿔서 바뀐 문자열들의 합이 최대를 구하는 문제.
```
sort(letters.begin(), letters.end());
letters.erase(unique(letters.begin(), letters.end()), letters.end());
``` 
방식으로 배열내 중복되는 문자제거 가능. 내림차 순의 가장 큰 숫자배열을
next_permutation 돌리면서 중복제거된 문자열의 문자들에 대입해서 최댓값 찾음.

**스타트와링크(14889) : 인원들을 first, second 팀으로 분배후 능력치 합의
차이의 최솟값을 구하는 문제. 인원들을 똑같은 수의 0,1 배열의 next_permutation으로 순열화함.
절댓값 구하는 함수 : abs, min_element, max_element 사용시 *붙이기, push_back할려면 vector길이 설정x(값 변경이아닌 추가라서)

**연산자 끼워넣기(14888) : 고정된 숫자들 사이에 연산자 배열을 집어넣어 최솟값, 최댓값을 구하는 문제. 연산자들을 숫자화하여 연산자 배열에 집어넣고 next_permutation해서 최댓값, 최솟값 구함.
```
auto ans = minmax_element(result.begin(), result.end());
cout << *ans.second << '\n';
cout << *ans.first << '\n';
```
방식으로 배열내 최대,최소값을 구할수 있음.

두동전(16197) : nxm 칸의 보드에서 두동전을 상하좌우 한블록씩 동시이동시켜 10번내로 한개의 동전을 보드밖으로 이동시키기 위한 최소이동횟수, 혹은 10번을 초과하면 -1을 return 하는 문제.
```
if (ans == -1 || ans > temp) {
ans = temp;
}
```
방식으로 최솟값 구할수 있음. 재귀함수의 흐름은 보통 완료조건, 불가능조건, 다음계산 식으로 진행됨. return 값이 있는 재귀함수는
```
int temp = go(step+1, nx1, ny1, nx2, ny2);
if (temp == -1) continue;
if (ans == -1 || ans > temp) {
ans = temp;
}
}
return ans;
}
```
같은 형태임. 어려워서 가능하면 void 값 재귀함수가 나을듯함.

**로또(6603) : 한 배열내에서 그 배열의 크기보다 작은 배열을 모두 구하는 문제. 배열들을 index단위로 선택하냐, 선택하지 않느냐해서 재귀함수로 풀 수 있음. 

부분수열의 합(14225) : 로또와 마찬가지로 배열의 index단위로 선택하냐, 선택하지 않느냐해서 재귀함수로 풀 수 있음.

**에너지모으기(16198) : 구슬 배열에서 구슬하나를 제거하고 양옆의 구슬에너지의 곱을 얻을수 있고 이를 재귀함수로 해결하는 문제. return 값있는 재귀함수 형태임.
```
b.erase(b.begin()+i);
```
방식으로 배열내의 값 제거가능함.

테트로미노(14500) : 테트로미노의 칸은 상하좌우로 연속된 4개의 칸으로 이루어져 있으므로, 재귀함수로 풀 수 있음. 한 칸을 기준으로 만들수 있는 모든 테트로미노를 구하는 방식. 뫼산 모양의 테트로미노는 연속된 칸으로
만들수 없으므로 따로 구해줘야함.

**가르침(1062) : 단어내의 중복되는 알파벳을 처리하기 위해 단어를 알파벳의 비트마스크로 변환해서 해결하는 문제. 26개의 알파벳 중 k개를 고르기 위해 int 반환형 재귀함수를 사용함. 반환 있는 재귀함수의 전형적인 형태를 띔.

구슬탈출(13460) : 구슬을 nxm칸에서 한쪽으로 기울여 움직이는 문제. 한쪽으로 기울이는 문제는 동일방향 연속이동, 반대방향 연속이동을 차단해야 하기 때문에 4방향 이동을 4진수 비트마스크로 나타내어 해결함.
20자리 2진법수를 10자리 4진법수로 바꾸는 for문
```
vector<int> a(LIMIT);
for (int i=0; i<LIMIT; i++) {
a[i] = (k&3);
k >>= 2;
}
return a;
}
```

**부분수열의 합(14225) : 전형적인 비트마스크 문제. 수열의 index를 비트마스크로 설정하여 해당 수열의 모든 부분수열을 구할 수 있음.
나올수 없는 가장 작은 자연수를 구하는 문제는 bool 배열을 사용하여 해결할 수 있음.

**스도쿠(2580) : 해당 칸에 스도쿠 조건을 만족시키면서 수를 넣어보는 백트래킹 재귀 함수 문제. 3x3칸에서도 스도쿠 조건을 적용시켜야 하기 때문에 3x3크기로 2차원 배열을 분할할 수 있어야 함.

알파벳(1987) : 알파벳으로 이루어진 2차원 칸에서 중복되는 알파벳을 밟지 않고 말을 이동시키는 문제. 지나온 알파벳을 기록하기 위해 bool 배열을 사용해서 해결함. 백트래킹 문제로 재귀함수를 사용함.

**Nqueen(9663) : 전형적인 백트래킹 문제. 행 단위로 queen을 한개씩 두기 때문에 행 단위로 백트래킹 재귀함수를 진행시킴. 제한 조건은 queen들이 서로를 공격할 수 없도록 세로, 대각선에 중복되게 놓이지 않게 함.