#   브루트포스  
  -순열  (부등호, 단어수학, 연산자끼워넣기, 스타트와링크)  
  -재귀  (로또, 부분수열의합(1,2), 연산자끼워넣기(1,재귀), 테트로미노, 두동전, 에너지모으기, 백트래킹(nqueen,스도쿠,알파벳))  
  -비트마스크  (부분수열의합(비트), 가르침, 구슬탈출2, 2048(EASY))
  -백트래킹  (스도쿠, 알파벳, nqueen)
  
#  BFS 
  -4연산, DSLR, 데스나이트, 돌그룹, 레이저통신, 뱀과사다리게임, 벽부수고이동하기1, 벽부수고이동하기2, 벽부수고이동하기3, 벽부수고이동하기4, 소수경로, 아기상어, 연구소, 움직이는미로탈출, 적록색약  

#  그리디 알고리즘
  -30,가장 긴 증가부분수열2, 동전0, 동전뒤집기, 보석도둑(1,2), 수묶기, 순회강연, 잃어버린괄호, 전구와스위치, 행렬, 회의실배정, A와B, AB, ATM
 
#  분할 정복  
  -이분탐색  (숫자카드(1,2))  
  -mergesort  (배열합치기, mergesort)
  -quicksort  (quicksort)
  -버블소트, 별찍기(10,11), 사분면, 종이의개수, 트리의순회, 하노이탑이동순서, Z



부등호(2529) : 부등호 배열을 우선배치하고 그 배열에 맞는 가장 크고 작은 숫자배열을 찾는문제. next_permutation 사용(permutation 전에 sorting 필요), 가장 큰 숫자배열은 가장 큰 수들 987...의 배열임.

단어수학(1339) : 문자열 들의 알파벳을 숫자로 바꿔서 바뀐 문자열들의 합이 최대를 구하는 문제.
```
sort(letters.begin(), letters.end());
letters.erase(unique(letters.begin(), letters.end()), letters.end());
``` 
방식으로 배열내 중복되는 문자제거 가능. 내림차 순의 가장 큰 숫자배열을
next_permutation 돌리면서 중복제거된 문자열의 문자들에 대입해서 최댓값 찾음.

스타트와링크(14889) : 인원들을 first, second 팀으로 분배후 능력치 합의
차이의 최솟값을 구하는 문제. 인원들을 똑같은 수의 0,1 배열의 next_permutation으로 순열화함.

연산자 끼워넣기(14888) : 고정된 숫자들 사이에 연산자 배열을 집어넣어 최솟값, 최댓값을 구하는 문제. 연산자들을 숫자화하여 연산자 배열에 집어넣고 next_permutation해서 최댓값, 최솟값 구함.
```
auto ans = minmax_element(result.begin(), result.end());
cout << *ans.second << '\n';
cout << *ans.first << '\n';
```
방식으로 배열내 최대,최소값을 구할수 있음.

*두동전(16197) : nxm 칸의 보드에서 두동전을 상하좌우 한블록씩 동시이동시켜 10번내로 한개의 동전을 보드밖으로 이동시키기 위한 최소이동횟수, 혹은 10번을 초과하면 -1을 return 하는 문제.
```
if (ans == -1 || ans > temp) {
ans = temp;
}
```
방식으로 최솟값 구할수 있음. 재귀함수의 흐름은 보통 완료조건, 불가능조건, 다음계산 식으로 진행됨. return 값이 있는 재귀함수는
```
int temp = go(step+1, nx1, ny1, nx2, ny2);
if (temp == -1) continue;
if (ans == -1 || ans > temp) {
ans = temp;
}
}
return ans;
}
```
같은 형태임. 어려워서 가능하면 void 값 재귀함수가 나을듯함.

로또(2758) : 한 배열내에서 그 배열의 크기보다 작은 배열을 모두 구하는 문제. 배열들을 index단위로 선택하냐, 선택하지 않느냐해서 재귀함수로 풀 수 있음. 

부분수열의 합(14225) : 로또와 마찬가지로 배열의 index단위로 선택하냐, 선택하지 않느냐해서 재귀함수로 풀 수 있음.

**에너지모으기(16198) : 구슬 배열에서 구슬하나를 제거하고 양옆의 구슬에너지의 곱을 얻을수 있고 이를 재귀함수로 해결하는 문제. return 값있는 재귀함수 형태임.
```
b.erase(b.begin()+i);
```
방식으로 배열내의 값 제거가능함.

테트로미노(14500) : 테트로미노의 칸은 상하좌우로 연속된 4개의 칸으로 이루어져 있으므로, 재귀함수로 풀 수 있음. 한 칸을 기준으로 만들수 있는 모든 테트로미노를 구하는 방식. 뫼산 모양의 테트로미노는 연속된 칸으로
만들수 없으므로 따로 구해줘야함.

2048(easy)(12100) : 

